# Learning Vue.js
### Introduction
#### 1.1 Is Vue for you?
Welcome to Learning Vue.js. I'm Uzzal Kumar Roy and if you're looking to become a more efficient and versatile front end developer, then you're in the right place. In this course, I'll talk about the reasons that we use frameworks like Vue.js in the first place and how to quickly get up and running with nothing more than a browser and a text editor. We'll take a detailed look at how to manage form controls and dynamic attributes of HTML elements. You'll learn how to take advantage of Vue's powerful reactivity system that allows us to keep our UI in sync with our data model and how to use Vue's flexible computed properties that are cached for optimal performance. There are many different reasons that developers choose one framework over another or end up loving a particular framework. If you're not a regular user of any framework yet, or if you're looking to switch to one that you're more comfortable with, then by the end of this course, you'll have a solid understanding of whether Vue can play a role in helping you get your work done or build your next passion project.
#### 1.2 What you should know
To get the most possible out of this course, you should already be comfortable working with basic HTML and CSS. You should also have some experience with JavaScript including ECMAScript2015 syntax or ECMAScript 6 as it was formerly known. Some familiarity with the command line, Node.JS, and the npm package manager will be helpful, but the overwhelming majority of videos involve only the use of a text editor and a browser.

### 1. Managing Dynamic Content and Behavior
#### 1.1 What problems does Vue.js solve?
Before writing any code. I want to spend a few minutes talking about our motivation for using Vue.js and the problems that it aims to solve as a framework for JavaScript applications. In the days when libraries like jQuery were first widely used, or even earlier, it was common to write JavaScript code that looked like this. The purpose of this function is to add an element to the Dom or document object model. Our in memory representation of the webpage. In turn, updating the onscreen representation for the user. But after the call to appendElement on the first line this function is almost entirely concerned with updating the rest of the UI to make sure everything stays in a consistent state. While we could extract some of this logic to another reusable function, the point is that we need to explicitly do this additional work to keep the UI in sync, whenever we make a small change. And the more complex the UI becomes the more code it takes to manage all of that. Managing complexity is something I often think about when using Vue, the concept is self-explanatory but I probably first came across the term in Steve McConnell's classic book, Code Complete. He calls it Software's Primary Technical Imperative. If we can accept that managing complexity is at least one of our chief concerns as web developers whether we're talking about the code itself or just how our software can help a user complete a complex task, then it makes sense to use tools that are designed to manage or reduce that complexity that go beyond what's available out of the box. The native Dom API that you see used here on this MDN web docs page, was really designed with just making dynamic updates to the Dom even possible and not with managing the complexity that's involved with doing that in a large application. A better approach for our hypothetical example, if we could achieve it somehow, would be to set up triggers, when we initialize the app for those cascading updates to happen automatically, whenever we add or even remove or edit a row in our table. Then we could just call appendElement without having to wrap it in the function that also handles keeping the UI in sync. This makeSureEverythingStaysInSyncFromNowOn concept is where frameworks like Vue.js really shine. And it's a large part of why we use them to build our applications. We say that Vue is reactive. Its easy to set things up so that the UI is kept in sync with the underlying data, by automatically reacting to changes in that data. It's also progressive. It's easy to get started with nothing more than a script tag in order to add a small amount of dynamic behavior to your app. And then you can progressively add more features and tools as needed, as your app grows and becomes more sophisticated. It's declarative, we can set up the relationships and calculations required to keep our UI in sync when our application starts and then not have to worry about them later when managing user interactions and other updates. Finally, it's composable. We'll see that you can structure your application using Vue's component system for easier code reuse and easier reasoning about your applications logic and state. In the next video, we'll jump right in and talk about how to add Vue.js to a new or existing project.
#### 1.2 Adding Vue.js to a project
Whether you're starting a new project or you have an existing project that you're considering using Vue for, getting set up is simple. At the time I'm recording this course, the Get Started button on the vuejs.org homepage still points to the version 2 guide. So instead, we'll click up here to get to the version 3 guide and then click Get Started. So, if I click this Installation button here I'm presented with several different ways to get set up. The first, Import from a CDN, really just means adding a script tag to an HTML page. And I could do that with the CDN URL, or I could download it and host the script locally. If you're familiar with the command line package manager, NPM then you probably know that most JavaScript libraries and frameworks that are still used today are available as downloadable packages that can be automatically installed with those tools. Vue CLI, or command line interface, is just a more sophisticated way of installing Vue with a package manager along with some other useful development tools and some skeleton code to help you get started. To keep things simple for now, we'll grab the URL from the CDN page, but instead of using this script tag I'm going to copy this URL and then use the URL of the specific version that that redirects to. So, in case, you are following along, you can ensure that you're using the same version that I'm using in the video, which is 3.0.7. In the exercise files for this video you'll find index.hmtl. This will be the starting point for our example project, which will be a flashcard app. This page pulls in a style sheet and a data file, none of which is specific to vue.js. The CSS just helps us see what's changing a little bit better as we build out the app and makes it a little prettier. So don't worry about its content. And the data file just contains an array of JavaScript objects that represent flashcards, each with a front and a back property. So, the front is the name of an item, or a concept and the back is its description, sort of like questions and answers. So, we'll add the script tag down here under the data file. And then, in the next video, we'll talk about how Vue can manage this section of the document, this div, to dynamically render it using some of the flashcard attributes from our data file.
#### 1.3 Configuring dynamic elements
In order to configure our Vue app so that it can manage part of our page, we'll add another script element down here making sure that it appears after the one that loads the Vue framework. Next I'm going to declare a new constant called FlashcardApp. And by the way, you'll see const used in this way in the Vue 3 guide as well. A discussion of why that makes sense as opposed to var or let is beyond the scope of this course, but feel free to ask in the Q&A tab if you want to know more about that. So this is not really the app itself, but an object that describes it by representing some options that we're going to pass to a method that will create the app. One of those options is the data that our app is going to work with, and we declare that with a function called data that returns an object. The object that the data function returns will contain, for now, just a property called deckName, the name of our flashcard deck. And this is going to be Vue.js Fundamentals. This is going to be a deck of flashcards related to Vue.js concepts, but this app could actually be used to present any deck of flashcards. And this is all we need to get going for now. So on a new line, I'm going to call Vue.createApp, passing in our options object. And then chain onto that a call to mount, which will take a selector for the DOM element that we want Vue to manage for us by mounting the app on it. In this case, we can use this div up here that already has an ID of app. So just like a CSS selector, I'm going to do #app. And now what does this allow us to do? Well, instead of having to write code that, say, selects this H1 element and imperatively sets the inner text, I can just declaratively say that I want the inner text of this element to be the value of our deck name data property, and I can do that using the mustache or double curly brace syntax. The other benefit to this is that it's very easy now for someone to come along later on, and that someone may be you in the future, and just quickly scan this HTML template, and have a good idea of what's going on as compared to when you have some code in a script somewhere that's explicitly accessing this element's inner text value. So if I go over to the browser now and refresh, I can see that deck name has now been replaced by Vue.js Fundamentals. One problem with this is that you might notice a brief flicker of the curly braces when the page is loading before Vue has a chance to take over and replace the div that it's mounted on with its own version. In the next video, we'll look at a simple solution for this, and also explore some other ways to bind data to DOM elements.
#### 1.4 Binding to inner text and HTML
In this video, we'll start to get a sense of Vue's reactivity system and observe how the UI changes when the underlying data changes. First, to get rid of that flash of curly braces when the page loads. One we can do that is just to not put anything between the "h1" tags, to not use the curly braces, and instead opt to use the "v-text" directive which is a special attribute that we can use to bind the inner text to our "deckName" data property. So now when we refresh, there's no sign of curly braces because we aren't using them anymore. Now let's take a step toward displaying some flashcard data by adding our cards array to our view data. So, we'll add a new property in our data object called "cards" that will initialize with the value "cards" from the data file. And, this type of property declaration, where the name and the value are the same is so common that we've had a shortcut for it since ES 2015 and in this case it would just be "cards". So let's see if we can just display the content of the first card by setting the inner text of this "h2", I'll remove "item" here, to "cards", the first element at index zero, ".front" And, the inner text of this "div" to "cards[0].back". If we refresh, we can see that content but one problem we have is that you'll notice that there's a little bit of HTML in the description here. Since we're using "v-text" to set the inner text, that HTML is going to be escaped and if we want to render it as HTML, we should use the "v-html" directive instead. Another problem is that we don't want to show both the front and the back of the card at the same time. We'll see some cleaner ways to handle this later but one way to approach this is to add a new property called "flipped" which will keep track of whether this card has been flipped over or not and it'll be "false" initially. It's worth mentioning that you can use any single expression for the value provided to "v-text" or "v-html" even a ternary expression like this. So we're saying that if the value of "flipped" is "true", we want an empty string here 'cause the card's been flipped over, otherwise the content of the front like we had it before and then the opposite for the back. Sometimes when I start putting ternary expressions in my templates, it will feel a little bit messy to me and that's a signal that I might need to structure something differently. But, for now, it's good to know that we can do this if we need to. Let's use this as an opportunity to observe the reactive behavior that's so important to all modern JavaScript frameworks which will instantly bring our UI in sync with the underlying data whenever it changes. So first we'll save a reference to our created app in a new variable named "app" and now, having done that, we can refresh the browser and then if we open up the dev tools in the console, I can type "app.flipped" and notice that it shows the default value of "false". If I set "app.flipped" to "true", the DOM is updated immediately. This is the power of a declarative, reactive UI. Next we'll look at one way to set up a mechanism to allow the user to flip the card themselves.
#### 1.5 Dynamic attributes and v-model
Next I want to take a quick look at how to bind data properties, to an elements attributes. Let's say that we wanted to add a link for more information down here. The link text will be read more and, it will point to the Vue guide. But if we want to our app to be a generic solution for any kind of flashcard deck, we would probably have our URL as part of the data, and we can just call it readMoreUrl and initialize it to that same value. All we have to do now, to use our data property in place of this hard-coded href value, is replace it with readMoreUrl, and change href to v-bind:href. So now if I refresh, I have a link down here, with a dynamic href value. One way to simplify your template or your markup, is just to remove the v-bind part, leaving only :href, this is just a shorthand version of the v-bind syntax, and it's usage is very common. In fact for the rest of the course we'll be using the shorthand syntax, instead of the v-bind syntax. Next, I'm going to add a text field up here just to experiment a little with. (keyboard crunching) And if I wanted to pre-populate this with an initial value, I could do the same thing with v-bind value or just :value. Let's create a new data property called user input, and down in our data object we'll give it a default value. (keyboard crunching) And we'll just say default for now. So going back up here again I'm just applying this markup and CSS to make it all a little bit easier to see. And we'll invite the user to type something. So now when I refresh, I see the default value there, and if I go to the console, and do app.userInput to access our data property, I see that it has the value default, and, I can also reassign it to some other value, and once I hit enter, I see that reflected on the page immediately. But one limitation with this is that the data is only flowing in one direction, from Vue to the DOM. So if I go up here and I type, something else, it's not going to be reflected, when I evaluate app.userInput again it still says some other value. And I'm certainly going to want my app to have access to that updated value. To solve this problem, we can just use instead of :value, the v-model directive to set up that two way binding. So now when the user edits this field, it will automatically update our user input data property. So let's test this by checking for the word flip, and using user input, as a mechanism for flipping the card. So instead of flipped here, I'm going to ask if user input is equal to flip, and we'll do the same thing right below, instead of, flipped we have that conditional expression. So now when I refresh, and type the word flip, notice I don't even have to submit the form, I don't even have a form actually, and in fact, this field isn't even named, but as soon as I type the P, we got the card to flip, and then if I change it or just hit backspace, it unflips it, that's because the reactivity mechanism is based on the native input event that's being raised every time I type a character. So here we have a very declarative very reactive setup to handle this user input, but of course a simple click to flip the card would be better so we'll look at that next.
#### 1.6 Handling events with v-on
Now we'll see just how easy it is to respond to a click event in order to flip our card. I've removed the text fields that we were using in the last video, and also reintroduced our previous logic where we were checking the value of the flipped data property. If we want to allow the user to click anywhere on a card and have it flipped to show the back, all we have to do is set up a click handler on this div, using the v-on directive. So v-on:click. And then for the value, I can add a statement for what I want to happen. In this case, I want to toggle the Boolean value flipped. So we just set it to its opposite. So now when I refresh, I can click to flip the card as many times as I want. v-on also has a shorthand syntax. And it's an @ symbol instead of the v-on:. Again, this is very common so we'll be using this form throughout the rest of the course. Another thing that's overdue to be addressed is the fact that we're only loading the first card in the deck at index zero. Let's change this to Index and we'll add a new data property called Index to keep track of the current index in the array. So down here, I'll add it after cards. Index, and we'll initialize it to zero to show the first card. Next, let's add a button to advance to the next slide. This HTML entity that I'm typing is just a forward arrow. And I'm going to wrap this in a div with class navigation. That's just something that's already in my style sheet that'll help me center this. Now we'll add a click handler with @click. And this time, instead of using an inline statement, we're going to encapsulate our logic in a method named move. So then down in my options object, I'm going to add a key for methods which takes an object containing the methods. And we'll add the move method. So this will just increment the value of Index. And while we're inside a method, we could access Index through our app variable down here. Or we could just say this.Index. And this will just increment the value again. One reason that it's nice to use a method is that it's a lot cleaner than putting something in the template if we need to add additional logic here. For example, it would be a good idea to reset the value of flipped. So we see the front of the next card and not the back as I'm cycling through. Now, when I refresh, I'm able to move forward in the deck and cycle through the cards. So I named this method move instead of next or advance because I knew I wanted to use it to move in either direction and not just forward. So up in the template, notice that I don't need parentheses here if I'm not passing a parameter. This is actually calling the method. But if I created another button with a left arrow, then I could pass negative one or one to indicate the direction I want to move. Back down here in the method, I could call this parameter change. And instead of doing Index++, I can now do Index plus equals the change. We should be careful to not go outside the bounds of our array. So let's just test, this.cards and then this.Index plus change for a truthy value just to see if that index exists. Otherwise we won't try to move. So either way, it will keep our HTML template a lot cleaner if we keep all of this logic in a method. So now I have my two arrows. And I can move both ways. In the next chapter, we'll take a deeper dive into how to work with various form controls in Vue.

### 2. Form Control Bindings
#### 2.1 Text field bindings
In this video, we'll take a look at a very simple HTML form, and talk about how to manage text fields using Vue. In my code editor, you can see that this is indeed a form element with an input of type text and then a text area for lengthier input. And then below we have the submit button. Our view app is created the same way as before and I'm starting with a data object that has only the deck name property for now. So we've already seen that we can use v-bind value, or the shorthand version, just colon value to pre-populate a text field with a given value. And remember that value could be a data property, or a JavaScript expression. Or even something like math dot random. So let's use deck name instead. And if this were an existing flashcard deck that we were just editing, it might be perfectly fine to preload that value, and then just use a traditional form submission to update it. But if we did that, why would we bother using Vue at all in that case? Because it's still might help us manage some dynamic behavior that we want to add. For instance, I might want to display the length of this value here. So inside double curly braces I could say deck name dot length, and then the word characters after. So this shows us that the current value is 19 characters long. The only problem is that it doesn't change when I edit the fields. And that's because we haven't set up that two way data binding. We've used Vue to render a text field with a dynamic value, but we haven't told it to update the data property when the input changes. To do that remember, we need to use the v-model directive, instead of a dynamic value. So now that we see, as I remove characters or as I type more, we're writing the new value to our view instance with every keystroke and updating the UI accordingly. V-model and colon value work the same way with the text area. So if you're familiar with text areas, you know that a pre-populated value usually goes between the text area tags. You should avoid doing that when using Vue.js, even though it might seem to work in some cases. But usually we want that two way data binding, so we should use v-model anyway. Let's add a property called deck description. And then I'll add it to my data object initialized to an empty string. Of course, a more typical example of counting the length of an input would be to indicate a limit. So if our limit for deck description were say, 200 characters, then we could add the curly braces here and say, 200 minus deck description dot length. And we could say that that many characters are still available, or that many characters are left. So now if I refresh again, as I type you can see that number being updated on the fly. So that should give you a good introduction to managing text fields with Vue. Next, we'll take a look at check boxes.
#### 2.2 Using v-model with related checkboxes
Let's take a look at some ways that we can work with checkboxes in Vue. So, here you can see that I've added some options to the Deck Settings page, so far, I've only added some basic HTML, nothing related to Vue or any kind of dynamic behavior. Let's take a look at this first checkbox, include reverse cards just means that, the user would be presented with both sides of the card as they go through the deck. So, they may be shown a description and they'll have to come up with the name of the item and vice versa. One way we might deal with managing the state of this particular checkbox within our Vue app is to set up a data property that's associated with it, which we could call, reverse. This will be a Boolean value because it's just going to keep track of whether this checkbox is checked or unchecked. So, we would initialize to false. And then we would connect that to the checkbox using v-model, so, v-model = reverse and note that the value attribute here really isn't serving any purpose, but we'll leave it for now because we'll use it in another way in a moment. To help us see this in action, let's add another div down here where we just display the value of reverse. So, you can say the value of reverse is, and I'll make it bold and we can just display it as a string. So, now when I refresh, you can see the default value is false. And as I toggled the state of this checkbox, you can see a change there. Let's say you're dealing with a legacy system that's expecting a parameter named reverse, that set to either on or off when we post this form. To handle that, we could use the true-value and false-value directives. So, I could say, when this is checked, I want its value to be on and when it's unchecked, I want the value to be off. So, now when I toggle the checkbox, you see, on and off, instead of true and false, note that I didn't change the default value of false, so we still saw that one first. In this case, you'd probably want to just change that to off. Another way we can handle these checkboxes is as a group, in Vue, it's typical to use the same v-model property on a group of related checkboxes. So, instead of being named individually, we could use the name options and then copy that to the other two checkboxes. And then down in data, instead of reverse, we could have options initialized to an empty array. So, what that will do is store all of the values of the checked boxes in an array for us. And again, to see this in action, let's just display the array as a string up here. So, instead of value of reversed, I'll show selected options and that will just cast it to a string and show us what we've selected. So now, as I'm checking and unchecking these boxes, you can see the values are added to our options array and they're kept in sync with the state of the checkboxes. Next, we'll take a look at radio buttons and select elements which usually behave in a similar fashion.
#### 2.3 Configuring radio buttons and select elements
Now we'll find out how to bind data to radio buttons, and then we'll do the same for select elements, also known as drop-downs. So here we have a couple of related radio buttons in a field set for an additional option called leech action, with one of two values, tag or suspend. Leech is a term that I'm borrowing from a popular flashcard program called Anki, which gets his name from the Japanese word for memorization. Anki defines leeches as cards that you tend to have trouble with repeatedly. So you'll have the choice to either temporarily suspend them or just tag them as leeches for reference. Much like a group of related check boxes, I'll use the same V-model property on each radio button element. And we'll call it leech. So I'll add V-model equals leech, and then copy that to the next radio button. (computer keys clicking) And then in our data object down here, we'll add leech and we can let it default to tag because that's the first one that appears. Instead of displaying the selected value on the page or looking at it in the JavaScript console, let's track this value using the Vue JS devtools extension, which is available for Chrome and Firefox, or as a standalone app. I happen to be using Firefox at the moment. So I'm just going to search for Firefox Vue devtools. At the time I'm recording this course, the first value here will still install the Vue two version, although it might be different for you by the time you watch the course. But for me, the Vue three version is still in beta, so I'm going to look at this third result here and visit the GitHub repository, scroll down to installation, and click on beta channel next to the Firefox add-on. I'll click on the first release in the list and then click on this XPI file down here. Continue to installation, and allow it to be added to Firefox. And now you should see this little V in the upper right. If we go back to our page and click on that V, we should see a message telling us that Vue JS was detected on this page and suggesting that we opened the devtools and look for the Vue panel under the Vue tab. So I usually do that with F12, and if you don't see it right away, try refreshing the page, closing and opening the dev tools again. And there it is. So over on the right, I have the Vue tab, and if I click that, then I can click route which corresponds to my route Vue instance. Then I should be able to see all of my data over here on the right, including the value for leech, which I can confirm changes from tag to suspend as I toggle those radio buttons. Next, let's take a look at this select element here which offers some possible categories to assign to our flashcard deck. Again, if I want to manage the selected value with Vue, perhaps to post the options as JSON, to an API with an Ajax request, I can simply add V-model (computer keys clicking) and I'll call it category ID. (computer keys clicking) And then let's make sure that we add category ID to our data down here. (computer keys clicking) And we can initialize it with the same value as the default that just invites the user to select, which is an empty string. And to ensure that we've set this up correctly, (computer mouse clicks) I can refresh and take a look at the Vue dev tools. You can see this default category ID empty string and watch it change as we select different options from the dropdown. So seeing that ID changed there makes me confident that I can access the selected value in the dropdown, when necessary, from my Vue logic.
#### 2.4 Adding modifiers
View includes several directive modifiers that provide shorthand syntax for adding certain behaviors. For example, if we look at the deck name property in view DevTools, we can see that the bound value increases in length if I just hit the Space bar a few times. We might want to write some code in a submit event handler that trims that string before sending it to the server. But we have a convenient alternative in the trim modifier which is basically as easy as just typing the word trim in our template. So we'll do that right after the V model for deck name. So this becomes V-model.trim. If I go back and refresh, and if you watch deck name now in the view DevTools, you can see that no matter how many times I press the Space bar, the bound value in our data object doesn't change. But of course this only handles leading or trailing white space. So if I start typing out here, I'll get a long string with that space in the middle. Again, it's nice that View keeps our form fields and our data in sync with every keystroke. It does that by handling the native input event. But what if we didn't want that? What if we only wanted to update our data property after the user has finished typing and then moved the focus away from that field? We can tell you to handle the change event instead of the input event, by adding the lazy modifier. So if we do V-model.lazy equals deck description then you can see that typing in this text area, has no effect on the value we see in the DevTools until I hit Tab. Next, the category ID values are treated as strings by the browser. You can see that if I select biology, say the value for category ID is now the string three. But it may be helpful at times to automatically cast those to integers. That can be accomplished with the number modifier. So if I change this to the V-model.number, equals category ID, when I refresh and select biology again, I now have three as a number type. Other modifiers exist for use with event handlers. The one that I use the most is probably the prevent modifier. So if I were to add a V on click or the shorthand version, just @click to this submit button and have it call a method named submit. Recall that I would need to add a key down here in our options for methods, and then define the submit method. For now let's just have it pop an alert that says that we're submitting the form. So now if I make some changes and then I click the create button, it pops the alert, but once I hit, okay the browser submits the form and refreshes the page. If I want it to prevent that default behavior I could just do, @click.prevent. Now we can handle this submission however we want, again, perhaps with an AJAX call and a client site update. There are a few other modifiers that will come in handy at times, including stop for stopping event propagation, self for detecting whether the target was this element or a child element. And once for limiting the handler to a single execution. For now, we'll wrap up this chapter with a discussion of View's computed properties feature which is a great example of how powerful its reactivity system is.
#### 2.5 Computed properties

### 3. Rendering and Styling Logic
#### 3.1 Conditional rendering with v-if
#### 3.2 Conditional rendering with v-show
#### 3.3 Looping and list rendering with v-for
#### 3.4 Binding style attributes
#### 3.5 Binding CSS classes

### 4. Using Vue Components
#### 4.1 Creating and registering components
#### 4.2 Using component props
#### 4.3 Configuring custom events
### 4.4 Using component slots
#### 4.5 Installing Vue CLI
### Creating single file components

### Next steps

